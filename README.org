#+TITLE: Robust, Intuitive Programming Language (~ripl~)
#+SUBTITLE: Motivation, Design and Implementation
#+AUTHOR: Ian McCall
#+LATEX_HEADER: \usepackage[margin=0.6in]{geometry}
#+LATEX_HEADER: \hypersetup{ colorlinks=true, linkcolor=black, urlcolor=blue }

#+LATEX_HEADER: \usepackage[scale=0.9]{sourcecodepro}

#+LATEX_HEADER: \usepackage[utf8]{inputenc}

#+LATEX_HEADER: \usepackage{enumitem}   
#+LATEX_HEADER:  \setlist{noitemsep}
#+LATEX_HEADER:  \setlistdepth{9}
#+LATEX_HEADER:   \setlist[itemize,1]{label=-}
#+LATEX_HEADER:   \setlist[itemize,2]{label=-}
#+LATEX_HEADER:   \setlist[itemize,3]{label=-}
#+LATEX_HEADER:   \setlist[itemize,4]{label=-}
#+LATEX_HEADER:   \setlist[itemize,5]{label=-}
#+LATEX_HEADER:   \setlist[itemize,6]{label=-}
#+LATEX_HEADER:   \setlist[itemize,7]{label=-}
#+LATEX_HEADER:   \setlist[itemize,8]{label=-}
#+LATEX_HEADER:   \setlist[itemize,9]{label=-}
#+LATEX_HEADER:   \renewlist{itemize}{itemize}{9}

#+LATEX: \newpage

** Abstract
~ripl~ is a nascent programming language and the subject of my undergraduate thesis at UBC. Written in Scala with an LLVM back-end, ~ripl~ is intended to combine the safety and purity of a language like Haskell, with the efficient, low-level capabilities of a language like C++ or Rust, and the metaprogramming capabilities of a language like Racket or D. It is motivated by my appreciation for a wide range of language features and my inability to find any existing language that can provide all of these features.

** Features at a Glance
- Compiled
- Strong, static typing
- Type inference
- Strict evaluation
- Type-safe discriminated unions
- Null safety
- Pattern matching
- Mutable data structures
- Type-level constraints on the mutability of data and purity of functions
- Name overloading
- Subtyping via built-in and user defined implicit conversions
- Parametric polymorphism and type-level programming via templates
- Compile time function evaluation
- Expression oriented
- Readable, uniform syntax that is suitable for metaprogramming, inspired by [[https://sourceforge.net/p/readable/wiki/Home/][Readable Lisp S-expressions]]

** Minimal Examples
Below is a program to compute the meaning of life[fn:1], that demonstrates function definition and constant definition and usage.

#+NAME: meaning-of-life
#+BEGIN_SRC racket
    define meaning-of-life 42
    define (main) meaning-of-life
#+END_SRC

~ripl~'s syntax is expression oriented (like Haskell, Lisp, Rust and Scala, among others) in that most syntactic constructs in ~ripl~ are expressions that yield a value of some kind (unlike C, C++, C#, Java, JavaScript and Python, among others). More specifically, ~ripl~'s syntax is Lisp-like and inspired by [[https://sourceforge.net/p/readable/wiki/Home/][Readable Lisp S-expressions]], an extension of S-expressions that allows expressions to be grouped by whitespace, among other things. 


Below are two small examples that demonstrate definition of constnats, definition of functions, parameter type annotations, return type annotations, function application, if-expressions and recursion.

Expressions are grouped by parenthesis, or by whitespace according to the following rules:
1. Expressions on a line are grouped.
2. Lines may be continued via indentation.

#+NAME: factorial
#+BEGIN_SRC racket
    define (factorial (int n)) int
      if (<= n 1)
        1
        * n (factorial (- n 1))

    define (main) (factorial 5)
#+END_SRC

*** Meaning of Life
*** Factorial Function

** Design Goals and Corresponding Features
The following section provides an overview of ~ripl~'s design goals and the language features that are intended to achieve these goals.

*** Robust
The language enables the programmer to establish a wide range of constraints in the type system, by means of the following features:
- Strong, static typing
- Type-safe discriminated unions
- Type-level constraints on the mutability of data
- Type-level constraints on the existence of data (null-safety)
- Type-level constraints on the purity of functions
- Parametric polymorphism via templates
- Constraints on template parameters via type-classes/traits
- Type-level programming via templates and compile-time function evaluation
- The language will be memory-safe, though whether this is achieved via garbage collection or a Rust-style ownership system is yet to be determined.

**** Static Typing
Static typing has a wide range of applications and advantages. It can catch errors earlier in the development process and nearer to the source than the corresponding runtime errors, can improve performance by informing optimizations and reducing the number of runtime checks because data types are known in advance, can be used to disambiguate names via overload resolution (as in C++, C#, Câ™¯, D, Java, and Scala), can ensure that only certain functions have side effects (as in D and Haskell), can ensure that only certain aspects of certain variables can be modified (as in C++, D and Rust), and can be used as a basis for metaprogramming (as in Haskell, C++ and D).

When combined with type inference, these advantages can be leveraged with little-to-no increase in program length or programmer effort. As such the primary motivation for ~ripl~ is to embrace static typing and to extend the range of invariants that can be encoded within the type system at compile time, so that the language can be used to develop robust programs with predictable behaviour at any scale.

**** Type-Safe Discriminated Unions
Type-safe discriminated unions (as seen in Haskell, ML, Rust and Scala, among others) provide a very powerful and intuitive way of modelling polymorphic data and computations that may take one of a number of forms (e.g. ~(Some value)~ or ~None~, ~(Result value)~ or ~(Error message)~, ~(NonEmpty head tail)~ or ~Empty~, etc.).

Although discriminated unions are analogous in some respects to OOP style inheritance subtyping (which can even be used as a basis for discriminated unions, as in Scala), I would argue that type-safe discriminated unions when used in conjunction with pattern matching, result in code that is more robust, precise, straightforward and less tightly coupled than OOP style inheritance. As such, discriminated unions are an important feature of ~ripl~'s design, the advantages of which are highlighted in the following section on null-safety, for which they provide an excelent solution.

**** Type-Level Constraints on Existence (null-safety)

When my knowledge of programming was limited to imperative and object oriented languages, dependent typing was the only solution I could think of for the problem of null-safety and  I thought that dependent typing was the only viable solution for null-safety and other problems pertaining to the existence of data and potential for errors. Since becoming familiar with functional programming by learning Haskell, I'm glad to see that the solution is much simpler: 


 in object-oriented programming looked at many of the problems in imperative and object-oriented languages, and assumed that dependent typing would be the solution

Before learning Haskell and becoming familiar with functional programming, I believed that dependent typing was the solution for null-safety and other problems pertaining to the existence of data in object-oriented programming looked at many of the problems in imperative and object-oriented languages, and assumed that dependent typing would be the solution



are a powerful tool for authoring and composing data types, and are analogous in some respects to OOP style inheritance and subtyping (in Scala, for example, discriminated unions are created using inheritance). They provide a very powerful and intuitive way of modelling data and computations that may take one of a number of forms, 

Discriminated unions, as present in Haskell, ML, Scala


Although some statically-typed languages like C++ and Java are notoriously verbose and awkward, with concise and elegant, statically-typed languages like Haskell and Scala on offer, it's hard to understand the appeal of dynamic typing. The only case I can think of in which the flexibility of dynamic typing might be necessary is in enabling Lisp-style macros: a feature that is present only in a small minority of relatively unpopular dynamically typed languages, namely Lisp, Scheme and Racket.

Why then, the popularity of dynamically typed languages like Python, JavaScript and PHP? I don't know, any more than I can explain the popularity of Java, C and C++.

 The only advantage I can think of that dynamic typing might provide, are the advantages that dynamic typing  confer to


If the only staticaly typed languages on offer were verbose and unwieldy imperative languages like C++ and Java,
Having used dynamically typed languages like Emacs Lisp, JavaScript, Python, R and Racket, I've never really understood the appeal of dynamic typing. If the only statically typed alternatives were verbose and unwieldy imperative languages like C++ and Java, then I might understand, but with concise and elegant functional languages like Haskell and Scala on offer,  

Having used dynamically typed languages like Emacs Lisp, JavaScript, Python, R and Racket, I've never really understood the appeal of dynamic typing. If the only statically typed alternatives were verbose and unwieldy imperative languages like C++ and Java, then I might understand, but with concise and elegant functional languages like Haskell and Scala on offer,  
Personally I am a strong proponent of static typing and don't really understand the appeal of dynamic typing. 



**** Type-Level Constraints on Mutability

**** Type-Level Constraints on Purity

*** Performant
As a statically-typed and compiled language, ~ripl~ is suceptible to a wide range of optimizations, and has some inherent performance benefits over dynamically typed and/or interpreted languages.

As a statically-typed, compiled and strictly-evaluated language, ~ripl~ is suceptible to a similar range of optimizations as languages like C++ and Rust. Furthermore, by using LLVM-IR as a compile target, it's possible to leverage many of the optimizations developed for the C++ compiler Clang.

By allowing for mutation and mutable datastructures, ~ripl~ enables the efficient solution of problems that may be difficult or inefficient to solve in a purely functional language like Haskell. As a result of the type level constraints on mutability and purity mentioned in the previous section, these internal mutations can be encapsulated within purely-functional interfaces.
- Compiled
- Mutable datastructures
- Strict evaluation
- Explicit indirection

*** Concise and Intuitive
By emulating certain features of concise languages, like Haskell, Racket and Scala, it is hoped that this language can be made concise as well. What sets these languages apart from other more verbose languages?

Some languages are more ergonomic, concise and intuitive than others. Having worked for 2.5 years in C++, I'm fairly confident in the assertion that it is more verbose than Python. After translating an ~2000 line program at a job from Python to Scala, I found the Scala version to be ~20% shorter (in addition to being statically typed). After porting a complete set of LLVM bindings (llvm-hs) from Haskell to Scala (for this project), I found the Haskell version to be ~20% shorter as well.

After 2.5 years working full time in C++, for example, I would place this language at the bottom of this spectrum. Slightly better, I would suggest, are languages like C# and Python. 
- Type inference
- Subtyping via implicit conversions
- Name overloading
- Expression oriented
- Pattern matching
- Readable, uniform syntax, inspired by [[https://sourceforge.net/p/readable/wiki/Home/][Readable Lisp S-expressions]]

*** Powerful
- Type level programming via templates and compile-time function evaluation
- Type-level traits, akin to Haskell type-classes
- Lisp-style macros, enabled by the uniform syntax in combination with compile-time function evaluation

*** Minor Goals

**** TODO Lisp-style macros

**** TODO Deterministic destructor calls for resource disposal (RAII)

** Comparison with Other Languages
In an effort to compare this language with others in an objective and impartial way, I identified a number of quantifiable language features to be used as a basis for comparison. I then evaluated each language across these criteria, assigning a value of +1 for features that were present, a value of -1 for features that were absent, and a value of +0 for features that were not applicable, producing the following table:

*** Language Feature Table 
#+INCLUDE: "./doc/figures/language-features/table.org" :minlevel 1

Although this table is useful in detailing the features of each language, because it consists of more than 12 data-points in more than 30 dimensions, it is hard to visualize the high-level structure of the data and relationships between the languages by looking at the table itself. Fortunately, there are a number of data visualization methods that can help to visualize this higher dimensional data.

*** Hierarchical Clustering of Languages

One such visualization method is hierarchical clustering, which works by assigning each data point to its own group, and then repeatedly combining the two nearest groups (in n-dimensional space) until all data points have been organized into a binary tree. When applied to this data set, this process yields a taxonomy of programming languages based on the criteria mentioned above: 

[[file:doc/figures/language-features/hierarchical-clustering-of-languages.png]]

The results are consistent with my understanding of the languages considered, and help to place ripl in context. An annotated version of the tree above might look something like this:
    
- Languages considered
  - Statically typed, functional languages
    - ML-like (ML, Haskell)
    - Other (ripl, Rust)
  - Languages that are not both statically typed and functional
    - Low-level (C, LLVM-IR)
    - Higher-level
      - Dynamically typed
        - Scheme
        - Python, JavaScript
      - Statically typed
        - C++ and D (which was intended as a successor of C++)
        - Java-derived languages
          - Scala (the height at which it branches indicates it's disimilarity to C# and Java)
          - Java and C# (the most similar of any two languages considered)

*** TODO Hierarchical Clustering of Language Features

Incidentally, by running hierarchical clustering on the transpose of our table, it's possible classify the language features it contains by the programming languages in which they occur:

[[file:doc/figures/language-features/hierarchical-clustering-of-language-features.png]]

The result of this exercise provides some interesting insights: in particular, it suggests a strong correlation between garbage collection and memory safety (which may come as no surprise), and between pattern matching, type-safe discriminated unions and null-safety.

*** TODO Heatmap of Languages

[[file:doc/figures/language-features/heatmap-of-language.png]]

*** TODO Heatmap of Language Feature Correlations
Important to keep in mind is that this is descriptive and not predictive statistics

[[file:doc/figures/language-features/language-feature-correlation-heatmap-pearson.png]]

*** TODO Multidimensional Scaling of Languages

[[file:doc/figures/language-features/multidimensional-scaling-of-languages-non-metric.png]]

** Motivation and Rationale
*TODO*

** Examples
*TODO*

** Usage
*TODO*

** Misc TODO

*** DONE Move R code into its own file (it sortof sucks writing it in org mode)

*** DONE Get rid of PCA, MDS is better

*** DONE Exclude ripl from hierarchical clustering of features

*** DONE Experiment with other hierarchical clustering methods
The alternatives weren't as good as ward.d2

*** TODO Correlation analysis of language features

*** DONE Ensure that heatmap agrees with hierarchical clustering

*** TODO Get rid of classic MDS

*** TODO Scale the images appropriately for the paper, both for markdown and pdf export

*** TODO Consider removing plot titles

*** TODO Spread language feature table across multiple pages for latex export

*** TODO Try adding footnotes to the table to provide additional information, does it work with csv and latex export?

*** TODO Consider adding Dart and Lua as additional languages

*** TODO Consider heatmaps and multidimensional scaling of language features

*** TODO Use unicode sharp sign for C#
# Câ™¯

* Footnotes
[fn:1] a joke from The Hitchhiker's Guide to the Galaxy by Douglas Adams

* COMMENT Local Variables
# Local Variables:
# org-src-preserve-indentation: t
# org-src-fontify-natively: t
# org-block-background: (t (:background "#FFFFEA"))
# end:
