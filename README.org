#+TITLE: Robust Intuitive Programming Language (ripl)
#+SUBTITLE: Motivation, Design and Implementation
#+AUTHOR: Ian McCall
#+LATEX_HEADER: \usepackage[margin=0.8in]{geometry}
#+LATEX_HEADER: \hypersetup{ colorlinks=true, linkcolor=black, urlcolor=blue }

#+LATEX_HEADER: \usepackage{enumitem}   
#+LATEX_HEADER:  \setlist{noitemsep}
#+LATEX_HEADER:  \setlistdepth{9}
#+LATEX_HEADER:   \setlist[itemize,1]{label=-}
#+LATEX_HEADER:   \setlist[itemize,2]{label=-}
#+LATEX_HEADER:   \setlist[itemize,3]{label=-}
#+LATEX_HEADER:   \setlist[itemize,4]{label=-}
#+LATEX_HEADER:   \setlist[itemize,5]{label=-}
#+LATEX_HEADER:   \setlist[itemize,6]{label=-}
#+LATEX_HEADER:   \setlist[itemize,7]{label=-}
#+LATEX_HEADER:   \setlist[itemize,8]{label=-}
#+LATEX_HEADER:   \setlist[itemize,9]{label=-}
#+LATEX_HEADER:   \renewlist{itemize}{itemize}{9}

** Abstract
ripl is a nascent programming language and the subject of my undergraduate thesis at UBC. Written in Scala with an LLVM back-end, ripl is intended to combine the safety and purity of a language like Haskell, with the low-level capabilities of a language like C++ or Rust, and the metaprogramming capabilities of a language like Racket or D. It is motivated by my appreciation for a wide range of language features and my inability to find any one existing language that encompasses all of these features.

** Planned Features
- Compiled
- Strong, static typing
- Type inference
- Strict evaluation
- Type-safe discriminated unions
- Pattern matching
- Mutable data structures to support computationally intensive tasks
- Type-level constraints on the mutability of data and purity of functions
- Ad-hoc polymorphism (overloading) to promote programmer sanity
- Parametric polymorphism (templates/generics) to abstract over types and perform type-level programming
- A readable, uniform syntax that is suitable for metaprogramming, inspired by [[https://sourceforge.net/p/readable/wiki/Home/][Readable Lisp S-expressions]]

** Comparison with Other Languages
In an effort to compare this language with others in an objective and impartial way, I identified a number of quantifiable language features to be used as a basis for comparison. I then evaluated each language across these criteria, assigning a value of +1 for features that were present, a value of -1 for features that were absent, and a value of +0 for features that were not applicable, producing the following table:

*** Language Feature Table 
#+INCLUDE: "./doc/language-features/table.org" :minlevel 1

Although this table is useful in detailing the features of each language, because it consists of more than 8 data-points in more than 24 dimensions, it is hard to visualize the high-level structure of the data and relationships between the languages by looking at the table itself. Fortunately, there are a number of statistical methods that can help to visualize this higher dimensional data.

*** Hierarchical Clustering of Languages

One such data-visualization method is hierarchical clustering, which works by assigning each data point to its own group, and then repeatedly combining the two nearest groups (in n-dimensional space) until all data points have been organized into a binary tree. When applied to this data set, this process yields a taxonomy of programming languages based on the criteria mentioned above: 

[[file:doc/figures/language-features/hierarchical-clustering-of-languages.png]]

The results are consistent with my understanding of the languages considered, and help to place ripl in context. An annotated version of the tree above might look something like this:
    
- Languages considered
  - Statically typed, functional languages
    - ML-like (ML, Haskell)
    - Other (ripl, Rust)
  - Languages that are not both statically typed and functional
    - Low-level (C, LLVM-IR)
    - Higher-level
      - Dynamically typed
        - Scheme
        - Python, JavaScript
      - Statically typed
        - C++ and D (which was intended as a successor of C++)
        - Java-derived languages
          - Scala (the height at which it branches indicates it's disimilarity to C# and Java)
          - Java and C# (the most similar of any two languages considered)

*** TODO Hierarchical Clustering of Language Features

Incidentally, by running hierarchical clustering on the transpose of our table, it's possible classify the language features it contains by the programming languages in which they occur:

[[file:doc/figures/language-features/hierarchical-clustering-of-language-features.png]]

The result of this exercise provides some interesting insights: in particular, it suggests a strong correlation between garbage collection and memory safety (which may come as no surprise), and between pattern matching, type-safe discriminated unions and null-safety.

*** TODO Heatmap of Languages

[[file:doc/figures/language-features/heatmap-of-language.png]]

*** TODO Multidimensional Scaling of Languages

[[file:doc/figures/language-features/multidimensional-scaling-of-languages-non-metric.png]]

** Motivation and Rationale
*TODO*

** Examples
*TODO*

** Usage
*TODO*

** TODOs for language comparison

*** DONE Move R code into its own file (it sortof sucks writing it in org mode)

*** TODO Get rid of PCA, MDS is better

*** TODO Exclude ripl from hierarchical clustering of features

*** TODO Experiment with other hierarchical clustering methods

*** TODO Ensure that heatmap agrees with hierarchical clustering

*** TODO Scale the images appropriately for the paper, both for markdown and pdf export

*** TODO Consider removing plot titles

*** TODO Spread language feature table across multiple pages for latex export

*** TODO Try adding footnotes to the table to provide additional information, does it clash with csv export?

*** TODO Consider adding Dart and Lua as additional languages
